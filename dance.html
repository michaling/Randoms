<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level 3</title>
    <script src="shared.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            background-image:
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,255,255,.03) 2px, rgba(255,255,255,.03) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(255,255,255,.03) 2px, rgba(255,255,255,.03) 4px);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            image-rendering: pixelated;
        }

        .page-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            width: 95%;
            max-width: 1100px;
        }

        .game-frame {
            position: relative;
            border: 8px solid #4a90e2;
            box-shadow:
                0 0 0 4px #fff,
                0 0 0 12px #ff69b4,
                8px 8px 0 12px rgba(0,0,0,0.3);
            width: 100%;
            overflow: hidden;
            background: #111;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .hud {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0 4px;
        }

        .hud-item {
            color: #ff69b4;
            font-size: 1.4em;
            font-weight: bold;
            text-shadow: 2px 2px 0px rgba(74, 144, 226, 0.3);
            letter-spacing: 1px;
        }

        .controls-hint {
            color: #ff69b4;
            font-size: 0.9em;
            font-weight: bold;
            text-align: center;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            z-index: 10;
        }

        .overlay.hidden { display: none; }

        .overlay-text {
            color: #fff;
            font-size: 3em;
            font-weight: bold;
            text-shadow: 4px 4px 0 #ff69b4;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .overlay-sub {
            color: #ffcce0;
            font-size: 1.3em;
            font-weight: bold;
        }

        .overlay-btn {
            padding: 14px 50px;
            font-size: 1.4em;
            border: 4px solid #000;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            box-shadow: 6px 6px 0 rgba(0,0,0,0.3);
            text-transform: uppercase;
            letter-spacing: 2px;
            background: #ff69b4;
            color: white;
            transition: transform 0.1s;
        }

        .overlay-btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 8px 8px 0 rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <div class="hud">
            <span class="hud-item" id="scoreDisplay">Score: 0 / 10000</span>
            <span class="hud-item" id="comboDisplay">üî• Combo: 0</span>
            <span class="hud-item" id="strikesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
        </div>
        <div class="game-frame">
            <canvas id="danceCanvas" width="1000" height="700"></canvas>
            <div class="overlay" id="startOverlay">
                <div class="overlay-text">Level 3</div>
                <div class="overlay-sub">Dance Off! Match the moves!</div>
                <div class="overlay-sub">WASD or Arrow Keys</div>
                <button class="overlay-btn" id="startBtn">Start Dancing</button>
            </div>
            <div class="overlay hidden" id="gameOverOverlay">
                <div class="overlay-text">Too many misses!</div>
                <div class="overlay-sub" id="failScore">Score: 0</div>
                <button class="overlay-btn" id="retryBtn">Try Again</button>
            </div>
            <div class="overlay hidden" id="winOverlay">
                <div class="overlay-text">You smashed it!</div>
                <div class="overlay-sub" id="winScore">Score: 0</div>
                <div class="overlay-sub" id="winTotal">Total Score: 0</div>
                <button class="overlay-btn" id="replayBtn">Play Again</button>
            </div>
        </div>
        <br>
        <p class="controls-hint">Press WASD or Arrow Keys to match the arrows as they reach the target!</p>
    </div>

    <script>
    const canvas = document.getElementById('danceCanvas');
    const ctx = canvas.getContext('2d');
    const W = 1000, H = 700;

    // ============ LOAD CHARACTER DATA ============
    const youChar = JSON.parse(localStorage.getItem('valentineYou')) || {
        skinColor: '#FFDCB5', hairStyle: 'short', hairColor: '#3B2314',
        shirtColor: '#FF69B4', pantsColor: '#4169E1', eyeColor: '#3B2314', shoeColor: '#333333',
        bodyType: 'male'
    };
    const dateChar = JSON.parse(localStorage.getItem('valentineDate')) || {
        skinColor: '#FFDCB5', hairStyle: 'short', hairColor: '#3B2314',
        shirtColor: '#4a90e2', pantsColor: '#1A1A1A', eyeColor: '#4a90e2', shoeColor: '#333333',
        bodyType: 'female'
    };

    // ============ HELPERS ============
    function darken(hex, amt) {
        let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
        r = Math.max(0, r - amt); g = Math.max(0, g - amt); b = Math.max(0, b - amt);
        return '#' + [r,g,b].map(c => c.toString(16).padStart(2,'0')).join('');
    }

// ============ MUSIC ============
    const danceSongs = [
        'music/dance/Carousel.mp3',
        'music/dance/Get Back.mp3',
        "music/dance/Can't stop.mp3",
        'music/dance/Going Out.mp3',
        'music/dance/Girls & Boys.mp3'
    ];
    const randomSong = danceSongs[Math.floor(Math.random() * danceSongs.length)];
    const bgMusic = new Audio(randomSong);
    bgMusic.loop = true;
    bgMusic.volume = 0.5;

    // ============ GAME CONSTANTS ============
    const LANE_KEYS = ['a', 'w', 's', 'd'];
    const LANE_LABELS = ['‚¨ÖÔ∏è', '‚¨ÜÔ∏è', '‚¨áÔ∏è', '‚û°Ô∏è'];
    const LANE_COLORS = ['#ff6b9d', '#ffb347', '#87ceeb', '#98fb98'];
    const LANE_COUNT = 4;
    const LANE_WIDTH = 70;
    const LANE_GAP = 16;
    const LANES_TOTAL_W = LANE_COUNT * LANE_WIDTH + (LANE_COUNT - 1) * LANE_GAP;
    const LANES_X = (W - LANES_TOTAL_W) / 2;
    const TARGET_Y = H - 90;
    const SPAWN_Y = -40;
    const ARROW_SPEED = 1.8;
    const HIT_WINDOW = 55;
    const GOOD_WINDOW = 35;
    const PERFECT_WINDOW = 18;
    const WIN_SCORE = 10000;

    // ============ GAME STATE ============
    let gameState = 'start';
    let score = 0;
    let strikes = 0;
    const MAX_STRIKES = 3;
    let combo = 0;
    let maxCombo = 0;
    let frame = 0;
    let arrows = [];
    let nextSpawnFrame = 60;
    let spawnInterval = 45;
    let particles = [];
    let feedbackText = '';
    let feedbackTimer = 0;
    let feedbackColor = '#fff';
    let bgPulse = 0;
    let dancePhase = 0; // for character animation

    // ============ INPUT ============
    // Map both WASD and arrow keys to lane indices
    function keyToLane(key) {
        switch (key) {
            case 'a': case 'arrowleft': return 0;
            case 'w': case 'arrowup': return 1;
            case 's': case 'arrowdown': return 2;
            case 'd': case 'arrowright': return 3;
            default: return -1;
        }
    }

    document.addEventListener('keydown', e => {
        if (gameState !== 'playing') return;
        const key = e.key.toLowerCase();
        const laneIdx = keyToLane(key);
        if (laneIdx === -1) return;
        e.preventDefault();

        // Find closest arrow in this lane within hit window
        let bestArrow = null;
        let bestDist = Infinity;
        for (const a of arrows) {
            if (a.lane !== laneIdx || a.hit) continue;
            const dist = Math.abs(a.y - TARGET_Y);
            if (dist < HIT_WINDOW && dist < bestDist) {
                bestDist = dist;
                bestArrow = a;
            }
        }

        if (bestArrow) {
            bestArrow.hit = true;
            let points = 1;
            if (bestDist < PERFECT_WINDOW) {
feedbackText = 'PERFECT!';
                feedbackColor = '#FFD700';
                points = 180;
            } else if (bestDist < GOOD_WINDOW) {
feedbackText = 'GREAT!';
                feedbackColor = '#98fb98';
                points = 120;
} else {
feedbackText = 'OK';
                feedbackColor = '#87ceeb';
                points = 100;
            }
            combo++;
            if (combo > maxCombo) maxCombo = combo;
            // Combo multiplier
            const comboBonus = Math.min(Math.floor(combo / 5) * 50, 250);
            points += comboBonus;
            score += points;
            feedbackTimer = 30;
            dancePhase = frame;

            // Spawn hit particles
            const lx = LANES_X + laneIdx * (LANE_WIDTH + LANE_GAP) + LANE_WIDTH / 2;
            spawnParticles(lx, TARGET_Y, LANE_COLORS[laneIdx]);

            bgPulse = 8;
        } else {
            // Wrong press ‚Äî just break combo, no strike
            combo = 0;
        }
    });

    // ============ PARTICLES ============
    function spawnParticles(x, y, color) {
        for (let i = 0; i < 10; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 4;
            particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 2,
                life: 1,
                color,
                size: 2 + Math.random() * 3
            });
        }
    }

    // ============ DRAW FUNCTIONS ============
    function drawBackground() {
        // Dark dance floor with pulse
        const pulseAmt = bgPulse * 3;
        const r = 26 + pulseAmt;
        const g = 26 + Math.floor(pulseAmt * 0.3);
        const b = 46 + pulseAmt;
        ctx.fillStyle = `rgb(${Math.min(255,r)},${Math.min(255,g)},${Math.min(255,b)})`;
        ctx.fillRect(0, 0, W, H);

        // Disco floor tiles
        const tileSize = 50;
        for (let ty = 0; ty < H; ty += tileSize) {
            for (let tx = 0; tx < W; tx += tileSize) {
                const ti = Math.floor(tx / tileSize) + Math.floor(ty / tileSize);
                const flicker = Math.sin(frame * 0.05 + ti * 1.5) * 0.04;
                if (ti % 2 === 0) {
                    ctx.fillStyle = `rgba(255, 105, 180, ${0.03 + flicker})`;
                } else {
                    ctx.fillStyle = `rgba(74, 144, 226, ${0.03 + flicker})`;
                }
                ctx.fillRect(tx, ty, tileSize, tileSize);
            }
        }

        // Spotlight beams
        ctx.globalAlpha = 0.06;
        for (let i = 0; i < 3; i++) {
            const bx = W * 0.25 + i * W * 0.25;
            const sway = Math.sin(frame * 0.02 + i * 2) * 40;
            ctx.fillStyle = LANE_COLORS[i + 1];
            ctx.beginPath();
            ctx.moveTo(bx + sway, 0);
            ctx.lineTo(bx - 60 + sway, H);
            ctx.lineTo(bx + 60 + sway, H);
            ctx.closePath();
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    function drawLanes() {
        for (let i = 0; i < LANE_COUNT; i++) {
            const lx = LANES_X + i * (LANE_WIDTH + LANE_GAP);

            // Lane background
            ctx.fillStyle = 'rgba(255,255,255,0.03)';
            ctx.fillRect(lx, 0, LANE_WIDTH, H);

            // Lane borders
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 1;
            ctx.strokeRect(lx, 0, LANE_WIDTH, H);

            // Target zone
            ctx.fillStyle = `rgba(${hexToRgb(LANE_COLORS[i])}, 0.15)`;
            ctx.fillRect(lx, TARGET_Y - HIT_WINDOW, LANE_WIDTH, HIT_WINDOW * 2);

            // Target ring
            ctx.strokeStyle = LANE_COLORS[i];
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.6 + Math.sin(frame * 0.1) * 0.2;
            ctx.strokeRect(lx + 5, TARGET_Y - 20, LANE_WIDTH - 10, 40);
            ctx.globalAlpha = 1;

            // Key label below
            ctx.fillStyle = LANE_COLORS[i];
            ctx.font = 'bold 18px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.globalAlpha = 0.7;
            ctx.fillText(LANE_KEYS[i].toUpperCase(), lx + LANE_WIDTH / 2, H - 25);
            ctx.globalAlpha = 1;
        }
    }

    function hexToRgb(hex) {
        const r = parseInt(hex.slice(1,3),16);
        const g = parseInt(hex.slice(3,5),16);
        const b = parseInt(hex.slice(5,7),16);
        return `${r},${g},${b}`;
    }

    function drawArrow(a) {
        const lx = LANES_X + a.lane * (LANE_WIDTH + LANE_GAP) + LANE_WIDTH / 2;
        const color = LANE_COLORS[a.lane];

        ctx.save();
        ctx.translate(lx, a.y);

        // Glow
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 0, 22, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Arrow emoji
        ctx.font = '28px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(LANE_LABELS[a.lane], 0, 0);

        ctx.restore();
    }

    function drawParticles() {
        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
        });
        ctx.globalAlpha = 1;
    }

    function drawFeedback() {
        if (feedbackTimer <= 0) return;
        const alpha = feedbackTimer / 30;
        const scale = 1 + (1 - alpha) * 0.3;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = feedbackColor;
        ctx.font = `bold ${Math.floor(36 * scale)}px "Courier New", monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(feedbackText, W / 2, TARGET_Y - 60);
        // Combo text
        if (combo >= 3) {
            ctx.font = `bold ${Math.floor(20 * scale)}px "Courier New", monospace`;
            ctx.fillStyle = '#FFD700';
            ctx.fillText(`${combo}x COMBO!`, W / 2, TARGET_Y - 95);
        }
        ctx.globalAlpha = 1;
    }

    function drawCharacters() {
        const dancing = gameState === 'playing';
        const beatFrame = Math.floor(frame / 8);
        const bounce = dancing ? Math.abs(Math.sin(frame * 0.15)) * 8 : 0;
        const sway = dancing ? Math.sin(frame * 0.1) * 5 : 0;
        // Extra energy when recently hit
        const recentHit = (frame - dancePhase) < 20;
        const extraBounce = recentHit ? Math.abs(Math.sin((frame - dancePhase) * 0.3)) * 6 : 0;

        const charY = 100;

        // You character (left)
        drawDancingChar(160 + sway, charY - bounce - extraBounce, youChar, beatFrame, dancing);

        // Date character (right)
        drawDancingChar(W - 160 - sway, charY - bounce - extraBounce, dateChar, beatFrame + 2, dancing);

        // Heart between them
        if (dancing) {
            const heartScale = 1 + Math.sin(frame * 0.12) * 0.2 + (recentHit ? 0.3 : 0);
            ctx.font = `${Math.floor(24 * heartScale)}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üíï', W / 2, charY + 20 - bounce);
        }
    }

    function drawDancingChar(cx, cy, ch, beatOff, dancing) {
        const armAngle = dancing ? Math.sin((frame + beatOff * 10) * 0.15) * 0.6 : 0;
        const legSpread = dancing ? Math.abs(Math.sin((frame + beatOff * 10) * 0.12)) * 4 : 0;

        // Head
        ctx.fillStyle = ch.skinColor;
        ctx.fillRect(cx - 8, cy, 16, 14);
        // Hair
        ctx.fillStyle = ch.hairColor;
        ctx.fillRect(cx - 8, cy - 4, 16, 7);
        // Eyes
        ctx.fillStyle = ch.eyeColor;
        ctx.fillRect(cx - 5, cy + 6, 3, 2);
        ctx.fillRect(cx + 2, cy + 6, 3, 2);
        // Mouth
        ctx.fillStyle = '#333';
        if (dancing) {
            // Smile
            ctx.fillRect(cx - 3, cy + 10, 6, 1);
            ctx.fillRect(cx - 2, cy + 11, 4, 1);
        }
        // Body
        ctx.fillStyle = ch.shirtColor;
        ctx.fillRect(cx - 10, cy + 15, 20, 16);
        // Arms (swing with beat)
        ctx.save();
        ctx.translate(cx - 10, cy + 17);
        ctx.rotate(-0.3 + armAngle);
        ctx.fillStyle = ch.skinColor;
        ctx.fillRect(-12, -2, 12, 4);
        ctx.restore();
        ctx.save();
        ctx.translate(cx + 10, cy + 17);
        ctx.rotate(0.3 - armAngle);
        ctx.fillStyle = ch.skinColor;
        ctx.fillRect(0, -2, 12, 4);
        ctx.restore();
        // Pants
        ctx.fillStyle = ch.pantsColor;
        ctx.fillRect(cx - 10, cy + 31, 20, 10);
        // Legs
        ctx.fillStyle = ch.pantsColor;
        ctx.fillRect(cx - 8 - legSpread, cy + 41, 6, 10);
        ctx.fillRect(cx + 2 + legSpread, cy + 41, 6, 10);
        // Shoes
        ctx.fillStyle = ch.shoeColor;
        ctx.fillRect(cx - 10 - legSpread, cy + 51, 8, 3);
        ctx.fillRect(cx + 2 + legSpread, cy + 51, 8, 3);
    }

    function drawProgressBar() {
        const barW = 200;
        const barH = 14;
        const barX = W / 2 - barW / 2;
        const barY = 12;
        const progress = Math.min(score / WIN_SCORE, 1);

        // Background
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(barX, barY, barW, barH);
        // Fill
        const grad = ctx.createLinearGradient(barX, 0, barX + barW, 0);
        grad.addColorStop(0, '#ff69b4');
        grad.addColorStop(1, '#FFD700');
        ctx.fillStyle = grad;
        ctx.fillRect(barX, barY, barW * progress, barH);
        // Border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barW, barH);
        // Label
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${score} / ${WIN_SCORE}`, W / 2, barY + barH / 2);
    }

    // ============ UPDATE ============
    function update() {
        if (gameState !== 'playing') { frame++; return; }

        frame++;

        // Decrease pulse
        if (bgPulse > 0) bgPulse -= 0.5;

        // Spawn arrows
        nextSpawnFrame--;
        if (nextSpawnFrame <= 0) {
            const lane = Math.floor(Math.random() * LANE_COUNT);
            arrows.push({ lane, y: SPAWN_Y, hit: false });

            // Occasionally spawn doubles (two arrows at once) - only later in the game
            if (score > 30 && Math.random() < 0.12) {
                let lane2 = Math.floor(Math.random() * LANE_COUNT);
                while (lane2 === lane) lane2 = Math.floor(Math.random() * LANE_COUNT);
                arrows.push({ lane: lane2, y: SPAWN_Y, hit: false });
            }

// Speed up over time - very gentle ramp
            spawnInterval = Math.max(60, 100 - Math.floor(score / 500) * 2);
            nextSpawnFrame = spawnInterval;
        }

// Move arrows - very gentle speed scaling
        const speed = ARROW_SPEED + Math.floor(score / 1000) * 0.1;
        arrows.forEach(a => { if (!a.hit) a.y += speed; });

        // Check for arrows that passed the target without being hit
        for (let i = arrows.length - 1; i >= 0; i--) {
            const a = arrows[i];
            if (!a.hit && a.y > TARGET_Y + HIT_WINDOW) {
                // Missed
                strikes++;
                combo = 0;
                feedbackText = 'MISS!';
                feedbackColor = '#ff4444';
                feedbackTimer = 25;
                a.hit = true; // mark so we don't count again

                if (strikes >= MAX_STRIKES) {
                    gameState = 'over';
                    bgMusic.pause();
                    bgMusic.currentTime = 0;
                    document.getElementById('failScore').textContent = 'Score: ' + score + ' / ' + WIN_SCORE;
                    document.getElementById('gameOverOverlay').classList.remove('hidden');
                }
            }
        }

        // Remove arrows that are off screen or hit
        arrows = arrows.filter(a => !(a.hit && (a.y > TARGET_Y + 60)));

        // Update particles
        particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1;
            p.life -= 0.03;
        });
        particles = particles.filter(p => p.life > 0);

        // Feedback timer
        if (feedbackTimer > 0) feedbackTimer--;

        // HUD
        document.getElementById('scoreDisplay').textContent = `Score: ${score} / ${WIN_SCORE}`;
        document.getElementById('comboDisplay').textContent = combo >= 2 ? `üî• ${combo}` : '';
        let strikesStr = '';
        for (let i = 0; i < MAX_STRIKES; i++) strikesStr += i < (MAX_STRIKES - strikes) ? '‚ù§Ô∏è' : 'üñ§';
        document.getElementById('strikesDisplay').textContent = strikesStr;

        // Check win
        if (score >= WIN_SCORE) {
            gameState = 'won';
            bgMusic.pause();
            bgMusic.currentTime = 0;
const finalScore = score + maxCombo * 10;
            setValentineLevelScore(3, finalScore);
            document.getElementById('winScore').textContent = 'Score: ' + score;
            document.getElementById('winTotal').textContent = 'Total Score: ' + getValentineTotalScore();
            document.getElementById('winOverlay').classList.remove('hidden');
        }
    }

    // ============ RENDER ============
    function render() {
        ctx.clearRect(0, 0, W, H);
        drawBackground();
        drawCharacters();
        drawLanes();
        arrows.forEach(a => { if (!a.hit) drawArrow(a); });
        drawParticles();
        drawFeedback();
        if (gameState === 'playing') drawProgressBar();
    }

    // ============ GAME LOOP ============
    function gameLoop() {
        update();
        render();
        requestAnimationFrame(gameLoop);
    }

    function startGame() {
        score = 0;
        strikes = 0;
        combo = 0;
        maxCombo = 0;
        frame = 0;
        arrows = [];
        particles = [];
        nextSpawnFrame = 90;
        spawnInterval = 80;
        feedbackText = '';
        feedbackTimer = 0;
        bgPulse = 0;
        dancePhase = 0;
        gameState = 'playing';
        bgMusic.currentTime = 0;
        bgMusic.play().catch(() => {});
        document.getElementById('startOverlay').classList.add('hidden');
        document.getElementById('gameOverOverlay').classList.add('hidden');
        document.getElementById('winOverlay').classList.add('hidden');
    }

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('retryBtn').addEventListener('click', startGame);
    document.getElementById('replayBtn').addEventListener('click', startGame);

    // Initial render
    gameLoop();
    </script>
</body>
</html>
