<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level 2</title>
    <script src="shared.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #a8d8ff;
            background-image:
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,255,255,.1) 2px, rgba(255,255,255,.1) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(255,255,255,.1) 2px, rgba(255,255,255,.1) 4px);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            image-rendering: pixelated;
        }

        .page-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            width: 95%;
            max-width: 900px;
        }

        .game-frame {
            position: relative;
            border: 8px solid #4a90e2;
            box-shadow:
                0 0 0 4px #fff,
                0 0 0 12px #ff69b4,
                8px 8px 0 12px rgba(0,0,0,0.3);
            width: 100%;
            overflow: hidden;
            background: #222;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .hud {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0 4px;
        }

        .hud-item {
            color: #4a90e2;
            font-size: 1.4em;
            font-weight: bold;
            text-shadow: 2px 2px 0px rgba(255, 105, 180, 0.3);
            letter-spacing: 1px;
        }

        .controls-hint {
            color: #ff69b4;
            font-size: 0.9em;
            font-weight: bold;
            text-align: center;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            z-index: 10;
        }

        .overlay.hidden { display: none; }

        .overlay-text {
            color: #fff;
            font-size: 3em;
            font-weight: bold;
            text-shadow: 4px 4px 0 #ff69b4;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .overlay-sub {
            color: #ffcce0;
            font-size: 1.3em;
            font-weight: bold;
        }

        .overlay-btn {
            padding: 14px 50px;
            font-size: 1.4em;
            border: 4px solid #000;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            box-shadow: 6px 6px 0 rgba(0,0,0,0.3);
            text-transform: uppercase;
            letter-spacing: 2px;
            background: #ff69b4;
            color: white;
            transition: transform 0.1s;
        }

        .overlay-btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 8px 8px 0 rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <div class="hud">
            <span class="hud-item" id="timerDisplay">‚è±Ô∏è 0:00</span>
            <span class="hud-item" id="scoreDisplay">Score: 0</span>
            <span class="hud-item" id="collectDisplay">üéÅ 0</span>
            <span class="hud-item" id="stepsDisplay">Steps: 0</span>
        </div>
        <div class="game-frame">
            <canvas id="mazeCanvas" width="640" height="640"></canvas>
            <div class="overlay" id="startOverlay">
                <div class="overlay-text">Level 2</div>
                <div class="overlay-sub">Find your way out of the wicked love maze</div>
                <button class="overlay-btn" id="startBtn">Start</button>
            </div>
            <div class="overlay hidden" id="winOverlay">
                <div class="overlay-text">You escaped!</div>
                <div class="overlay-sub" id="winScore">Score: 0</div>
                <div class="overlay-sub" id="winStats">Time: 0:00 ¬∑ Steps: 0 ¬∑ Collected: 0</div>
                <div class="overlay-sub" id="winTotal">Total Score: 0</div>
                <button class="overlay-btn" id="replayBtn">Play Again</button>
            </div>
        </div>
        <br>
        <p class="controls-hint">WASD or Arrow Keys to move through the maze</p>
    </div>

    <script>
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');
    const CW = 640, CH = 640;

    // ============ LOAD CHARACTER DATA ============
    const youChar = JSON.parse(localStorage.getItem('valentineYou')) || {
        skinColor: '#FFDCB5', hairStyle: 'short', hairColor: '#3B2314',
        shirtColor: '#FF69B4', pantsColor: '#4169E1', eyeColor: '#3B2314', shoeColor: '#333333',
        bodyType: 'male'
    };
    const dateChar = JSON.parse(localStorage.getItem('valentineDate')) || {
        skinColor: '#FFDCB5', hairStyle: 'short', hairColor: '#3B2314',
        shirtColor: '#4a90e2', pantsColor: '#1A1A1A', eyeColor: '#4a90e2', shoeColor: '#333333',
        bodyType: 'female'
    };
    const catChar = JSON.parse(localStorage.getItem('valentineCat')) || null;

    // ============ HELPERS ============
    function darken(hex, amt) {
        let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
        r = Math.max(0, r - amt); g = Math.max(0, g - amt); b = Math.max(0, b - amt);
        return '#' + [r,g,b].map(c => c.toString(16).padStart(2,'0')).join('');
    }
    function lighten(hex, amt) {
        let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
        r = Math.min(255, r + amt); g = Math.min(255, g + amt); b = Math.min(255, b + amt);
        return '#' + [r,g,b].map(c => c.toString(16).padStart(2,'0')).join('');
    }

    // ============ MAZE GENERATION (Recursive Backtracker + extra complexity) ============
    const COLS = 21, ROWS = 21;
    const CELL = CW / COLS; // ~30px per cell

    // Each cell stores which walls exist: { top, right, bottom, left } (true = wall present)
    let grid = [];

    function initGrid() {
        grid = [];
        for (let r = 0; r < ROWS; r++) {
            grid[r] = [];
            for (let c = 0; c < COLS; c++) {
                grid[r][c] = { top: true, right: true, bottom: true, left: true, visited: false };
            }
        }
    }

    function generateMaze() {
        initGrid();
        // Step 1: Recursive backtracker to create a perfect maze
        const stack = [];
        let current = { r: 0, c: 0 };
        grid[0][0].visited = true;
        stack.push(current);

        while (stack.length > 0) {
            const { r, c } = current;
            const neighbors = [];

            if (r > 0 && !grid[r-1][c].visited) neighbors.push({ r: r-1, c, dir: 'top' });
            if (r < ROWS-1 && !grid[r+1][c].visited) neighbors.push({ r: r+1, c, dir: 'bottom' });
            if (c > 0 && !grid[r][c-1].visited) neighbors.push({ r, c: c-1, dir: 'left' });
            if (c < COLS-1 && !grid[r][c+1].visited) neighbors.push({ r, c: c+1, dir: 'right' });

            if (neighbors.length > 0) {
                const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                if (next.dir === 'top') { grid[r][c].top = false; grid[next.r][next.c].bottom = false; }
                if (next.dir === 'bottom') { grid[r][c].bottom = false; grid[next.r][next.c].top = false; }
                if (next.dir === 'left') { grid[r][c].left = false; grid[next.r][next.c].right = false; }
                if (next.dir === 'right') { grid[r][c].right = false; grid[next.r][next.c].left = false; }
                grid[next.r][next.c].visited = true;
                stack.push(current);
                current = next;
            } else {
                current = stack.pop();
            }
        }

        // Step 2: Remove extra walls to create loops and multiple paths
        // This creates branching points where the player must choose
        const extraRemovals = Math.floor(ROWS * COLS * 0.12);
        for (let i = 0; i < extraRemovals; i++) {
            const r = Math.floor(Math.random() * ROWS);
            const c = Math.floor(Math.random() * COLS);
            const dirs = [];
            if (r > 0 && grid[r][c].top) dirs.push('top');
            if (r < ROWS-1 && grid[r][c].bottom) dirs.push('bottom');
            if (c > 0 && grid[r][c].left) dirs.push('left');
            if (c < COLS-1 && grid[r][c].right) dirs.push('right');
            if (dirs.length === 0) continue;
            const dir = dirs[Math.floor(Math.random() * dirs.length)];
            if (dir === 'top') { grid[r][c].top = false; grid[r-1][c].bottom = false; }
            if (dir === 'bottom') { grid[r][c].bottom = false; grid[r+1][c].top = false; }
            if (dir === 'left') { grid[r][c].left = false; grid[r][c-1].right = false; }
            if (dir === 'right') { grid[r][c].right = false; grid[r][c+1].left = false; }
        }

        // Step 3: Add some walls back in to create dead-end traps (seal off some corridors)
        // Find cells with 3-4 open sides and wall one off to make misleading forks
        const traps = Math.floor(ROWS * COLS * 0.06);
        for (let i = 0; i < traps; i++) {
            const r = 1 + Math.floor(Math.random() * (ROWS - 2));
            const c = 1 + Math.floor(Math.random() * (COLS - 2));
            // Count open sides
            const open = [];
            if (!grid[r][c].top) open.push('top');
            if (!grid[r][c].bottom) open.push('bottom');
            if (!grid[r][c].left) open.push('left');
            if (!grid[r][c].right) open.push('right');
            // Only add wall if cell has 3+ openings (creates a fork that now dead-ends)
            if (open.length >= 3) {
                const dir = open[Math.floor(Math.random() * open.length)];
                if (dir === 'top') { grid[r][c].top = true; grid[r-1][c].bottom = true; }
                if (dir === 'bottom') { grid[r][c].bottom = true; grid[r+1][c].top = true; }
                if (dir === 'left') { grid[r][c].left = true; grid[r][c-1].right = true; }
                if (dir === 'right') { grid[r][c].right = true; grid[r][c+1].left = true; }
            }
        }

        // Step 4: Ensure start and exit are reachable (BFS check, regenerate if not)
        if (!isReachable(0, 0, exitR, exitC)) {
            generateMaze(); // retry
        }
    }

    // BFS to verify the maze is solvable
    function isReachable(sr, sc, er, ec) {
        const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
        const queue = [{ r: sr, c: sc }];
        visited[sr][sc] = true;
        while (queue.length > 0) {
            const { r, c } = queue.shift();
            if (r === er && c === ec) return true;
            if (!grid[r][c].top && r > 0 && !visited[r-1][c]) { visited[r-1][c] = true; queue.push({ r: r-1, c }); }
            if (!grid[r][c].bottom && r < ROWS-1 && !visited[r+1][c]) { visited[r+1][c] = true; queue.push({ r: r+1, c }); }
            if (!grid[r][c].left && c > 0 && !visited[r][c-1]) { visited[r][c-1] = true; queue.push({ r, c: c-1 }); }
            if (!grid[r][c].right && c < COLS-1 && !visited[r][c+1]) { visited[r][c+1] = true; queue.push({ r, c: c+1 }); }
        }
        return false;
    }

    // ============ GAME STATE ============
    let gameState = 'start';
    let playerR = 0, playerC = 0;
    const exitR = ROWS - 1, exitC = COLS - 1;
    let steps = 0;
    let startTime = 0;
    let elapsed = 0;
    let frame = 0;
    let trail = []; // breadcrumb trail of visited cells
    let collected = 0;
    let totalPickups = 0;
    let collectParticles = [];

    // ============ SCORE CALCULATION ============
    // Base: 10000 points
    // + 100 per collectible picked up (nice bonus, not worth big detours)
    // - 15 per step taken (heavy penalty for wandering)
    // - 30 per second elapsed (heavy penalty for slowness)
    function calcScore() {
        const secs = Math.floor(elapsed / 1000);
        const base = 10000;
        const collectBonus = collected * 100;
        const stepPenalty = steps * 15;
        const timePenalty = secs * 30;
        return Math.max(0, base + collectBonus - stepPenalty - timePenalty);
    }

    // ============ BACKGROUND MUSIC ============
    const bgMusic = new Audio('music/Son Of Sam.mp3');
    bgMusic.loop = true;
    bgMusic.volume = 0.4;

    // ============ INPUT ============
    const keys = {};
    let lastMoveTime = 0;
    const MOVE_DELAY = 150; // ms between moves

    document.addEventListener('keydown', e => {
        const key = e.key.toLowerCase();
        if (['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'].includes(key)) {
            e.preventDefault();
        }
        keys[key] = true;
    });
    document.addEventListener('keyup', e => {
        keys[e.key.toLowerCase()] = false;
    });

    // ============ DRAW MAZE ============
    function drawMaze() {
        // Background - soft pink gradient
        const grad = ctx.createLinearGradient(0, 0, CW, CH);
        grad.addColorStop(0, '#FFF0F5');
        grad.addColorStop(1, '#FFE4E1');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, CW, CH);

        // Draw cells floor pattern
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const x = c * CELL;
                const y = r * CELL;
                // Checkerboard subtle pattern
                if ((r + c) % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 182, 193, 0.15)';
                    ctx.fillRect(x, y, CELL, CELL);
                }
            }
        }

        // Draw trail (breadcrumb hearts)
        trail.forEach((t, i) => {
            const x = t.c * CELL + CELL / 2;
            const y = t.r * CELL + CELL / 2;
            ctx.globalAlpha = 0.2 + (i / trail.length) * 0.3;
            ctx.fillStyle = '#ff69b4';
            ctx.font = '8px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üíó', x, y);
        });
        ctx.globalAlpha = 1;

        // Draw walls
        ctx.strokeStyle = '#c2185b';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const x = c * CELL;
                const y = r * CELL;
                const cell = grid[r][c];

                if (cell.top) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + CELL, y);
                    ctx.stroke();
                }
                if (cell.right) {
                    ctx.beginPath();
                    ctx.moveTo(x + CELL, y);
                    ctx.lineTo(x + CELL, y + CELL);
                    ctx.stroke();
                }
                if (cell.bottom) {
                    ctx.beginPath();
                    ctx.moveTo(x, y + CELL);
                    ctx.lineTo(x + CELL, y + CELL);
                    ctx.stroke();
                }
                if (cell.left) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + CELL);
                    ctx.stroke();
                }
            }
        }

        // Draw outer border thicker
        ctx.strokeStyle = '#880E4F';
        ctx.lineWidth = 5;
        ctx.strokeRect(0, 0, CW, CH);

        // Draw wall decorations - small hearts on some wall intersections
        ctx.fillStyle = '#e91e63';
        ctx.font = '6px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        for (let r = 0; r <= ROWS; r += 3) {
            for (let c = 0; c <= COLS; c += 3) {
                ctx.globalAlpha = 0.3 + Math.sin(frame * 0.03 + r + c) * 0.15;
                ctx.fillText('‚ô•', c * CELL, r * CELL);
            }
        }
        ctx.globalAlpha = 1;
    }

    // ============ DRAW EXIT ============
    function drawExit() {
        const x = exitC * CELL;
        const y = exitR * CELL;
        const pulse = 0.7 + Math.sin(frame * 0.08) * 0.3;

        // Glow
        ctx.globalAlpha = 0.2 * pulse;
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.arc(x + CELL / 2, y + CELL / 2, CELL * 0.6, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Exit marker - big golden heart
        ctx.font = (20 + Math.sin(frame * 0.1) * 3) + 'px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üö™', x + CELL / 2, y + CELL / 2 - 2);

        // Label
        ctx.fillStyle = '#c2185b';
        ctx.font = 'bold 8px "Courier New", monospace';
        ctx.fillText('EXIT', x + CELL / 2, y + CELL - 5);
    }

    // ============ DRAW START ============
    function drawStart() {
        const x = 0;
        const y = 0;
        ctx.fillStyle = 'rgba(76, 175, 80, 0.15)';
        ctx.fillRect(x, y, CELL, CELL);
        ctx.fillStyle = '#4CAF50';
        ctx.font = 'bold 8px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('START', x + CELL / 2, y + 8);
    }

    // ============ DRAW PLAYER (mini characters) ============
    function drawPlayer() {
        const px = playerC * CELL + CELL / 2;
        const py = playerR * CELL + CELL / 2;

        // Bobbing animation
        const bob = Math.sin(frame * 0.1) * 1.5;

        // Draw a simplified version of both characters side by side
        const size = 6; // tiny pixel size
        const youX = px - 10;
        const dateX = px + 2;
        const charY = py + bob - 2;

        // Simple "you" character
        drawMiniChar(youX, charY, youChar, size);
        // Simple "date" character
        drawMiniChar(dateX, charY, dateChar, size);

        // Cat between them
        if (catChar) {
            drawMiniCat(px - 4, charY + 10, catChar);
        }

        // Heart above
        const heartBob = Math.sin(frame * 0.12) * 2;
        ctx.font = '10px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üíï', px, py - 14 + heartBob);
    }

    function drawMiniChar(x, y, ch, s) {
        // Head
        ctx.fillStyle = ch.skinColor;
        ctx.fillRect(x, y, 8, 6);
        // Hair
        ctx.fillStyle = ch.hairColor;
        ctx.fillRect(x, y - 2, 8, 3);
        // Eyes
        ctx.fillStyle = ch.eyeColor;
        ctx.fillRect(x + 1, y + 2, 2, 1);
        ctx.fillRect(x + 5, y + 2, 2, 1);
        // Body
        ctx.fillStyle = ch.shirtColor;
        ctx.fillRect(x, y + 6, 8, 5);
        // Legs
        ctx.fillStyle = ch.pantsColor;
        ctx.fillRect(x + 1, y + 11, 2, 3);
        ctx.fillRect(x + 5, y + 11, 2, 3);
        // Shoes
        ctx.fillStyle = ch.shoeColor;
        ctx.fillRect(x, y + 14, 3, 1);
        ctx.fillRect(x + 5, y + 14, 3, 1);
    }

    function drawMiniCat(x, y, cat) {
        // Tiny cat
        ctx.fillStyle = cat.furColor;
        // Head
        ctx.fillRect(x + 1, y, 5, 4);
        // Ears
        ctx.fillRect(x, y - 1, 2, 2);
        ctx.fillRect(x + 5, y - 1, 2, 2);
        // Eyes
        ctx.fillStyle = cat.eyeColor;
        ctx.fillRect(x + 1, y + 1, 1, 1);
        ctx.fillRect(x + 4, y + 1, 1, 1);
        // Body
        ctx.fillStyle = cat.furColor;
        ctx.fillRect(x + 1, y + 4, 5, 3);
        // Tail
        ctx.fillRect(x + 6, y + 3, 1, 1);
        ctx.fillRect(x + 7, y + 2, 1, 1);
    }

    // ============ SCATTERED DECORATIONS ============
    // Pre-generate random decorations in certain cells
    const decoEmojis = ['üåπ', 'üíê', 'üç´', 'üíå', 'üß∏', 'üéÄ', '‚ú®', 'üíé'];
    const decorations = [];
    function generateDecorations() {
        decorations.length = 0;
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if ((r === 0 && c === 0) || (r === exitR && c === exitC)) continue;
                if (Math.random() < 0.12) {
                    decorations.push({
                        r, c,
                        emoji: decoEmojis[Math.floor(Math.random() * decoEmojis.length)],
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }
        }
    }

    function drawDecorations() {
        decorations.forEach(d => {
            const x = d.c * CELL + CELL / 2;
            const y = d.r * CELL + CELL / 2;
            const bob = Math.sin(frame * 0.06 + d.phase) * 2;
            const pulse = 1 + Math.sin(frame * 0.1 + d.phase) * 0.15;

            // Glow
            ctx.globalAlpha = 0.15 * pulse;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x, y, CELL * 0.35, 0, Math.PI * 2);
            ctx.fill();

            // Emoji
            ctx.globalAlpha = 0.85;
            ctx.font = (10 + pulse) + 'px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(d.emoji, x, y + bob);
        });
        ctx.globalAlpha = 1;
    }

    function spawnCollectParticles(cx, cy, emoji) {
        const colors = ['#FFD700', '#ff69b4', '#FFF8DC', '#FFB6C1'];
        for (let i = 0; i < 10; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 2;
            collectParticles.push({
                x: cx, y: cy,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 1,
                life: 1,
                color: colors[Math.floor(Math.random() * colors.length)]
            });
        }
    }

    function drawCollectParticles() {
        collectParticles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - 1, p.y - 1, 3, 3);
        });
        ctx.globalAlpha = 1;
    }

    // ============ UPDATE ============
    function update() {
        if (gameState !== 'playing') return;

        frame++;
        elapsed = Date.now() - startTime;

        // Update collect particles
        collectParticles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.05;
            p.life -= 0.025;
        });
        collectParticles = collectParticles.filter(p => p.life > 0);

        const now = Date.now();
        if (now - lastMoveTime < MOVE_DELAY) {
            // Still update HUD even when not moving
            updateHUD();
            return;
        }

        let dr = 0, dc = 0;
        if (keys['w'] || keys['arrowup']) dr = -1;
        else if (keys['s'] || keys['arrowdown']) dr = 1;
        else if (keys['a'] || keys['arrowleft']) dc = -1;
        else if (keys['d'] || keys['arrowright']) dc = 1;

        if (dr === 0 && dc === 0) { updateHUD(); return; }

        const cell = grid[playerR][playerC];
        let canMove = false;

        if (dr === -1 && !cell.top) canMove = true;
        if (dr === 1 && !cell.bottom) canMove = true;
        if (dc === -1 && !cell.left) canMove = true;
        if (dc === 1 && !cell.right) canMove = true;

        if (canMove) {
            playerR += dr;
            playerC += dc;
            steps++;
            lastMoveTime = now;

            // Add to trail if not already there
            const alreadyInTrail = trail.some(t => t.r === playerR && t.c === playerC);
            if (!alreadyInTrail) {
                trail.push({ r: playerR, c: playerC });
            }

            // Check collectible pickup
            for (let i = decorations.length - 1; i >= 0; i--) {
                const d = decorations[i];
                if (d.r === playerR && d.c === playerC) {
                    collected++;
                    const cx = d.c * CELL + CELL / 2;
                    const cy = d.r * CELL + CELL / 2;
                    spawnCollectParticles(cx, cy, d.emoji);
                    decorations.splice(i, 1);
                }
            }

            // Check win
            if (playerR === exitR && playerC === exitC) {
                gameState = 'won';
                bgMusic.pause();
                bgMusic.currentTime = 0;
                const finalScore = calcScore();
                setValentineLevelScore(2, finalScore);
                const secs = Math.floor(elapsed / 1000);
                const mins = Math.floor(secs / 60);
                const remSecs = secs % 60;
                document.getElementById('winScore').textContent = 'Level Score: ' + finalScore;
                document.getElementById('winStats').textContent =
                    `Time: ${mins}:${remSecs.toString().padStart(2,'0')} ¬∑ Steps: ${steps} ¬∑ Collected: ${collected}/${totalPickups}`;
                document.getElementById('winTotal').textContent = 'Total Score: ' + getValentineTotalScore();
                document.getElementById('winOverlay').classList.remove('hidden');
            }
        }

        updateHUD();
    }

    function updateHUD() {
        const secs = Math.floor(elapsed / 1000);
        const mins = Math.floor(secs / 60);
        const remSecs = secs % 60;
        document.getElementById('timerDisplay').textContent = `‚è±Ô∏è ${mins}:${remSecs.toString().padStart(2,'0')}`;
        document.getElementById('scoreDisplay').textContent = 'Score: ' + calcScore();
        document.getElementById('collectDisplay').textContent = `üéÅ ${collected}/${totalPickups}`;
        document.getElementById('stepsDisplay').textContent = `Steps: ${steps}`;
    }

    // ============ RENDER ============
    function render() {
        ctx.clearRect(0, 0, CW, CH);
        drawMaze();
        drawDecorations();
        drawCollectParticles();
        drawStart();
        drawExit();
        if (gameState === 'playing') {
            drawPlayer();
        }
    }

    // ============ GAME LOOP ============
    function gameLoop() {
        update();
        render();
        requestAnimationFrame(gameLoop);
    }

    function startGame() {
        generateMaze();
        generateDecorations();
        totalPickups = decorations.length;
        collected = 0;
        collectParticles = [];
        playerR = 0;
        playerC = 0;
        steps = 0;
        frame = 0;
        trail = [{ r: 0, c: 0 }];
        startTime = Date.now();
        elapsed = 0;
        gameState = 'playing';
        bgMusic.currentTime = 0;
        bgMusic.play().catch(() => {});
        document.getElementById('startOverlay').classList.add('hidden');
        document.getElementById('winOverlay').classList.add('hidden');
    }

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('replayBtn').addEventListener('click', startGame);

    // Initial render - generate a maze for the background
    generateMaze();
    generateDecorations();
    gameLoop();
    </script>
</body>
</html>
